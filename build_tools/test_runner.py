#!/usr/bin/env python3
# Copyright 2022 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Runs test within Renode simulator."""
import argparse
import os
import re
import sys
import tempfile

import io
import pexpect


parser = argparse.ArgumentParser(
    description="Run a springbok test on an simulator.")

parser.add_argument("elf",
                    help="Elf to execute on a simulator")
parser.add_argument("--renode-path",
                    help="Path to renode simulator")
parser.add_argument("--trace-output",
                    help="Path to trace output file")
parser.add_argument("--timeout", type=int,
                    help="Timeout for test", default=1000)
parser.add_argument("--quick_test",
                    help="allow quickest test time", action="store_true")

args = parser.parse_args()

class Simulation: # pylint: disable=too-few-public-methods
    """ Base class for simulation """
    def __init__(self, simulator_cmd):
        self.simulator_cmd = simulator_cmd
        self.buffer = io.StringIO()
        self.child = None
        self.termination_strings = [
            "main returned",
            "Exception occurred",
            "ReadByte from non existing peripheral",
        ]

    def run(self, timeout=1000):
        """ Run the simulation command and quit the simulation."""
        self.child = pexpect.spawn(self.simulator_cmd, encoding="utf-8")
        self.child.logfile = self.buffer
        try:
            self.child.expect(self.termination_strings, timeout=timeout)
        except pexpect.exceptions.TIMEOUT:
            self.buffer.seek(0)
            message = ("Runner times out with the execution log: \n\n" +
                       cleanup_message(self.buffer.read()))
            exc = pexpect.exceptions.TIMEOUT(message)
            exc.__cause__ = None
            raise exc
        self.child.send("\nq\n")
        self.child.expect(pexpect.EOF, timeout=timeout)
        self.child.close()
        self.buffer.seek(0)
        return self.buffer.read()

class RenodeSimulation(Simulation): # pylint: disable=too-few-public-methods
    """ Renode Simulation """
    def __init__(self, path, elf):
        # Get the ROOTDIR path if it exists
        self.rootdir = os.environ.get("ROOTDIR", default=None)
        if self.rootdir is None:
            parser.error("ROOTDIR environment variable not set.")
        renode_script = """
$bin=@%(elf)s
path set @%(rootdir)s
include @sim/config/springbok.resc"""

        if args.quick_test:
            renode_script += """
sysbus.cpu2 PerformanceInMips 2000
emulation SetGlobalQuantum "1" """

        if args.trace_output:
            renode_script += """
sysbus.cpu2 EnableExecutionTracing @%(trace_file)s PCAndOpcode """

        renode_script += """
start
sysbus.vec_controlblock WriteDoubleWord 0xc 0"""
        self.script_params = {
            "elf": os.path.realpath(elf),
            "rootdir": self.rootdir,
            "trace_file": os.path.realpath(args.trace_output) if args.trace_output else ""
        }
        self.renode_script = renode_script % self.script_params
        self.renode_args = [
            "%s" % path,
            "--disable-xwt",
            " --console",
            "--plain",
        ]
        self.renode_simulator_cmd = " ".join(self.renode_args)
        super().__init__(self.renode_simulator_cmd)

    def run(self, timeout=120):
        file_desc, script_path = tempfile.mkstemp(suffix=".resc")
        try:
            with os.fdopen(file_desc, "w") as tmp:
                tmp.write(self.renode_script)
                tmp.flush()
            self.simulator_cmd += " %s" % script_path
            test_output = super().run(timeout=timeout)
        finally:
            os.remove(script_path)
        return test_output

Simulators = {
    "renode": RenodeSimulation,
}

simulators_paths = {
    "renode": args.renode_path,
}

def cleanup_message(message: str) -> str:
    """ Clean up the message to get rid of the non-ascii code generated by Mono. """
    ansi_escape = re.compile(r"\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])")
    output = ansi_escape.sub("", message)
    return output

def main():
    """ Run a test and check for Pass or Fail """
    simulator_path = simulators_paths["renode"]
    if simulator_path is None:
        parser.error(
            "Must provide path to Renode simulator")

    simulator_class = Simulators["renode"]
    simulator = simulator_class(simulator_path, args.elf)
    output = simulator.run(timeout=args.timeout)
    output = cleanup_message(output)
    print(output)
    failure_strings = [
        "FAILED",
        "Exception occurred",
        "ReadByte from non existing peripheral"
    ]
    if any(x in output for x in failure_strings):
        sys.exit(1)
    # Grab the return code from the output string with regex
    # Syntax: "main returned: ", <code> (<hex_code>)
    return_string = re.compile(
        r"\"main returned:\s\",(?P<ret_code>\s[0-9]+\s*)")
    code = return_string.search(output)
    sys.exit(int(code.group(1)))


if __name__ == "__main__":
    main()
